[
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231368",
    "pull_request_review_id": 3519629052,
    "id": 2572231368,
    "node_id": "PRRC_kwDOKLjsIc6ZUSLI",
    "diff_hunk": "@@ -0,0 +1,132 @@\n+const {log} = Candy.core('Log', false).init('Firewall')\n+\n+class Firewall {\n+  #blacklist = new Set()\n+  #whitelist = new Set()\n+  #requestCounts = new Map() // IP -> { count, timestamp }\n+  #config = {}\n+  #cleanupInterval = null\n+\n+  constructor() {\n+    this.load()\n+    // Run cleanup every minute\n+    this.#cleanupInterval = setInterval(() => this.cleanup(), 60000)\n+    if (this.#cleanupInterval.unref) this.#cleanupInterval.unref()\n+  }\n+\n+  load() {\n+    // Load configuration from Candy.core('Config').config\n+    const config = Candy.core('Config').config.firewall || {}\n+\n+    this.#config = {\n+      enabled: config.enabled !== false,\n+      rateLimit: {\n+        enabled: config.rateLimit?.enabled !== false,\n+        windowMs: config.rateLimit?.windowMs || 60000, // 1 minute\n+        max: config.rateLimit?.max || 300 // limit each IP to 300 requests per windowMs\n+      },\n+      blacklist: new Set(config.blacklist || []),\n+      whitelist: new Set(config.whitelist || [])\n+    }\n+\n+    this.#blacklist = this.#config.blacklist\n+    this.#whitelist = this.#config.whitelist\n+  }\n+\n+  check(req) {\n+    if (!this.#config.enabled) return true\n+\n+    let ip = req.socket.remoteAddress || req.headers['x-forwarded-for']\n+    if (ip && ip.startsWith('::ffff:')) {\n+      ip = ip.substring(7)\n+    }",
    "path": "server/src/Web/Firewall.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Incomplete IPv6 handling: The code only handles IPv6-mapped IPv4 addresses (e.g., `::ffff:127.0.0.1`), but doesn't handle native IPv6 addresses or other IPv6 formats. This means:\n1. Native IPv6 addresses won't be normalized consistently\n2. IPv6 addresses might not match correctly in blacklist/whitelist comparisons\n\nConsider adding proper IPv6 address normalization or documenting that only IPv4 and IPv6-mapped IPv4 addresses are supported.",
    "created_at": "2025-11-28T17:46:05Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231368",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231368"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231368"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231368/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 53,
    "original_start_line": 40,
    "start_side": "RIGHT",
    "line": 55,
    "original_line": 42,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 42,
    "position": 55,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231383",
    "pull_request_review_id": 3519629052,
    "id": 2572231383,
    "node_id": "PRRC_kwDOKLjsIc6ZUSLX",
    "diff_hunk": "@@ -0,0 +1,132 @@\n+const {log} = Candy.core('Log', false).init('Firewall')\n+\n+class Firewall {\n+  #blacklist = new Set()\n+  #whitelist = new Set()\n+  #requestCounts = new Map() // IP -> { count, timestamp }\n+  #config = {}\n+  #cleanupInterval = null",
    "path": "server/src/Web/Firewall.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "The private field `#cleanupInterval` is not accessible from tests. The test at line 42 tries to access `firewall.cleanupInterval`, but this will be `undefined` since the field is private. Consider either:\n1. Making this a public property (e.g., `this.cleanupInterval`)\n2. Providing a public cleanup method that clears the interval\n3. Removing the cleanup in `afterEach` if the interval uses `unref()` which already prevents keeping the process alive",
    "created_at": "2025-11-28T17:46:05Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231383",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231383"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231383"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231383/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 11,
    "original_line": 8,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 8,
    "position": 11,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231390",
    "pull_request_review_id": 3519629052,
    "id": 2572231390,
    "node_id": "PRRC_kwDOKLjsIc6ZUSLe",
    "diff_hunk": "@@ -0,0 +1,132 @@\n+const {log} = Candy.core('Log', false).init('Firewall')\n+\n+class Firewall {\n+  #blacklist = new Set()\n+  #whitelist = new Set()\n+  #requestCounts = new Map() // IP -> { count, timestamp }\n+  #config = {}\n+  #cleanupInterval = null\n+\n+  constructor() {\n+    this.load()\n+    // Run cleanup every minute\n+    this.#cleanupInterval = setInterval(() => this.cleanup(), 60000)\n+    if (this.#cleanupInterval.unref) this.#cleanupInterval.unref()\n+  }\n+\n+  load() {\n+    // Load configuration from Candy.core('Config').config\n+    const config = Candy.core('Config').config.firewall || {}\n+\n+    this.#config = {\n+      enabled: config.enabled !== false,\n+      rateLimit: {\n+        enabled: config.rateLimit?.enabled !== false,\n+        windowMs: config.rateLimit?.windowMs || 60000, // 1 minute\n+        max: config.rateLimit?.max || 300 // limit each IP to 300 requests per windowMs\n+      },\n+      blacklist: new Set(config.blacklist || []),\n+      whitelist: new Set(config.whitelist || [])\n+    }\n+\n+    this.#blacklist = this.#config.blacklist\n+    this.#whitelist = this.#config.whitelist\n+  }\n+\n+  check(req) {\n+    if (!this.#config.enabled) return true\n+\n+    let ip = req.socket.remoteAddress || req.headers['x-forwarded-for']",
    "path": "server/src/Web/Firewall.js",
    "commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Security vulnerability: The `x-forwarded-for` header can contain multiple IP addresses (e.g., \"client, proxy1, proxy2\"). Using the entire header value as the IP allows attackers to bypass rate limiting by adding different values to this header. Consider extracting only the first IP address:\n```javascript\nlet ip = req.socket.remoteAddress || req.headers['x-forwarded-for']?.split(',')[0]?.trim()\n```\n```suggestion\n    let ip = req.socket.remoteAddress || req.headers['x-forwarded-for']?.split(',')[0]?.trim()\n```",
    "created_at": "2025-11-28T17:46:05Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231390",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231390"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231390"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231390/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 39,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 39,
    "position": 1,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231400",
    "pull_request_review_id": 3519629052,
    "id": 2572231400,
    "node_id": "PRRC_kwDOKLjsIc6ZUSLo",
    "diff_hunk": "@@ -186,6 +189,12 @@ class Web {\n   }\n \n   request(req, res, secure) {\n+    if (!this.#firewall.check(req)) {\n+      res.writeHead(429, {'Content-Type': 'text/plain'})\n+      res.end('Too Many Requests')\n+      return",
    "path": "server/src/Web.js",
    "commit_id": "fac5be7607b208407a3eb251366e33668b49dcfd",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "The error message \"Too Many Requests\" might be too generic for users encountering blacklisted IPs. The firewall blocks both rate-limited requests AND blacklisted IPs, but both return a 429 status code with the same message. Consider:\n1. Using 403 Forbidden for blacklisted IPs\n2. Providing different messages to distinguish between rate limiting and IP blocking\n\nThis would help legitimate users understand why they're blocked.\n```suggestion\n    // Use checkReason if available, otherwise fallback to check\n    let firewallResult = typeof this.#firewall.checkReason === 'function'\n      ? this.#firewall.checkReason(req)\n      : (this.#firewall.check(req) ? 'ok' : 'rate-limit');\n    if (firewallResult !== 'ok') {\n      if (firewallResult === 'blacklist') {\n        res.writeHead(403, {'Content-Type': 'text/plain'});\n        res.end('Your IP has been blocked.');\n        return;\n      } else if (firewallResult === 'rate-limit') {\n        res.writeHead(429, {'Content-Type': 'text/plain'});\n        res.end('Too Many Requests');\n        return;\n      } else {\n        // fallback for unknown reason\n        res.writeHead(429, {'Content-Type': 'text/plain'});\n        res.end('Too Many Requests');\n        return;\n      }\n```",
    "created_at": "2025-11-28T17:46:06Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231400",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231400"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231400"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231400/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 192,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 195,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 31,
    "position": 1,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231411",
    "pull_request_review_id": 3519629052,
    "id": 2572231411,
    "node_id": "PRRC_kwDOKLjsIc6ZUSLz",
    "diff_hunk": "@@ -0,0 +1,106 @@\n+\n+// Mock dependencies\n+const mockLog = {\n+  log: jest.fn(),\n+  error: jest.fn(),\n+  init: jest.fn().mockReturnThis()\n+}\n+\n+// Mock Candy global\n+global.Candy = {\n+  core: jest.fn((module) => {\n+    if (module === 'Log') return mockLog\n+    if (module === 'Config') return {\n+      config: {\n+        firewall: {\n+            enabled: true,\n+            rateLimit: {\n+                enabled: true,\n+                windowMs: 1000,\n+                max: 2\n+            },\n+            blacklist: [],\n+            whitelist: []\n+        }\n+      }\n+    }\n+    return {}\n+  })\n+}\n+\n+const Firewall = require('../../../server/src/Web/Firewall.js')\n+\n+describe('Firewall', () => {\n+  let firewall\n+\n+  beforeEach(() => {\n+    jest.clearAllMocks()\n+    firewall = new Firewall()\n+  })\n+\n+  afterEach(() => {\n+     if (firewall.cleanupInterval) clearInterval(firewall.cleanupInterval)\n+  })\n+\n+  test('should allow requests from normal IPs', () => {\n+    const req = { socket: { remoteAddress: '127.0.0.1' }, headers: {} }\n+    expect(firewall.check(req)).toBe(true)\n+  })\n+\n+  test('should block requests from blacklisted IPs', () => {\n+    firewall.addBlock('1.2.3.4')\n+    const req = { socket: { remoteAddress: '1.2.3.4' }, headers: {} }\n+    expect(firewall.check(req)).toBe(false)\n+  })\n+\n+  test('should allow requests from whitelisted IPs even if rate limited', () => {\n+      // Mock rate limit config to be very strict\n+      firewall = new Firewall()\n+      // Manually set low limit\n+      firewall.addWhitelist('1.2.3.4')\n+\n+      const req = { socket: { remoteAddress: '1.2.3.4' }, headers: {} }\n+\n+      // Send many requests\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+  })\n+\n+  test('should enforce rate limits', () => {\n+      const req = { socket: { remoteAddress: '10.0.0.1' }, headers: {} }\n+\n+      // Config is max 2 per 1000ms\n+      expect(firewall.check(req)).toBe(true) // 1\n+      expect(firewall.check(req)).toBe(true) // 2\n+      expect(firewall.check(req)).toBe(false) // 3 - blocked\n+  })\n+\n+  test('should reset rate limits after window', async () => {\n+      const req = { socket: { remoteAddress: '10.0.0.2' }, headers: {} }\n+\n+      expect(firewall.check(req)).toBe(true) // 1\n+      expect(firewall.check(req)).toBe(true) // 2\n+      expect(firewall.check(req)).toBe(false) // 3\n+\n+      // Wait for window to pass (1000ms)\n+      await new Promise(resolve => setTimeout(resolve, 1100))\n+\n+      expect(firewall.check(req)).toBe(true) // Should be allowed again\n+  })\n+\n+  test('should handle IPv6 mapped IPv4 addresses', () => {\n+      const req = { socket: { remoteAddress: '::ffff:127.0.0.1' }, headers: {} }\n+      expect(firewall.check(req)).toBe(true)\n+\n+      firewall.addBlock('127.0.0.1')\n+      expect(firewall.check(req)).toBe(false)\n+  })\n+\n+  test('should use x-forwarded-for if socket address is missing', () => {\n+      const req = { socket: {}, headers: { 'x-forwarded-for': '1.2.3.4' } }\n+      firewall.addBlock('1.2.3.4')\n+      expect(firewall.check(req)).toBe(false)\n+  })",
    "path": "test/server/Web/Firewall.test.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Test coverage gap: The `addBlock()`, `removeBlock()`, `addWhitelist()`, and `removeWhitelist()` methods call `#save()` which updates the global config, but there are no tests verifying that the configuration is properly persisted. Consider adding tests to verify that these methods correctly update `Candy.core('Config').config.firewall.blacklist` and `Candy.core('Config').config.firewall.whitelist`.",
    "created_at": "2025-11-28T17:46:06Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231411",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231411"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231411"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231411/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 50,
    "original_start_line": 50,
    "start_side": "RIGHT",
    "line": 109,
    "original_line": 105,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 105,
    "position": 109,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231418",
    "pull_request_review_id": 3519629052,
    "id": 2572231418,
    "node_id": "PRRC_kwDOKLjsIc6ZUSL6",
    "diff_hunk": "@@ -0,0 +1,106 @@\n+\n+// Mock dependencies\n+const mockLog = {\n+  log: jest.fn(),\n+  error: jest.fn(),\n+  init: jest.fn().mockReturnThis()\n+}\n+\n+// Mock Candy global\n+global.Candy = {\n+  core: jest.fn((module) => {\n+    if (module === 'Log') return mockLog\n+    if (module === 'Config') return {\n+      config: {\n+        firewall: {\n+            enabled: true,\n+            rateLimit: {\n+                enabled: true,\n+                windowMs: 1000,\n+                max: 2\n+            },\n+            blacklist: [],\n+            whitelist: []\n+        }\n+      }\n+    }\n+    return {}\n+  })\n+}\n+\n+const Firewall = require('../../../server/src/Web/Firewall.js')\n+\n+describe('Firewall', () => {\n+  let firewall\n+\n+  beforeEach(() => {\n+    jest.clearAllMocks()\n+    firewall = new Firewall()\n+  })\n+\n+  afterEach(() => {\n+     if (firewall.cleanupInterval) clearInterval(firewall.cleanupInterval)\n+  })\n+\n+  test('should allow requests from normal IPs', () => {\n+    const req = { socket: { remoteAddress: '127.0.0.1' }, headers: {} }\n+    expect(firewall.check(req)).toBe(true)\n+  })\n+\n+  test('should block requests from blacklisted IPs', () => {\n+    firewall.addBlock('1.2.3.4')\n+    const req = { socket: { remoteAddress: '1.2.3.4' }, headers: {} }\n+    expect(firewall.check(req)).toBe(false)\n+  })\n+\n+  test('should allow requests from whitelisted IPs even if rate limited', () => {\n+      // Mock rate limit config to be very strict\n+      firewall = new Firewall()\n+      // Manually set low limit\n+      firewall.addWhitelist('1.2.3.4')\n+\n+      const req = { socket: { remoteAddress: '1.2.3.4' }, headers: {} }\n+\n+      // Send many requests\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+  })\n+\n+  test('should enforce rate limits', () => {\n+      const req = { socket: { remoteAddress: '10.0.0.1' }, headers: {} }\n+\n+      // Config is max 2 per 1000ms\n+      expect(firewall.check(req)).toBe(true) // 1\n+      expect(firewall.check(req)).toBe(true) // 2\n+      expect(firewall.check(req)).toBe(false) // 3 - blocked\n+  })\n+\n+  test('should reset rate limits after window', async () => {\n+      const req = { socket: { remoteAddress: '10.0.0.2' }, headers: {} }\n+\n+      expect(firewall.check(req)).toBe(true) // 1\n+      expect(firewall.check(req)).toBe(true) // 2\n+      expect(firewall.check(req)).toBe(false) // 3\n+\n+      // Wait for window to pass (1000ms)\n+      await new Promise(resolve => setTimeout(resolve, 1100))\n+\n+      expect(firewall.check(req)).toBe(true) // Should be allowed again\n+  })",
    "path": "test/server/Web/Firewall.test.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Missing test coverage: The `cleanup()` method that runs periodically to clear old IP records from memory is not directly tested. While it's called via the interval, consider adding a test that:\n1. Makes requests from an IP\n2. Manually advances time or waits\n3. Calls `cleanup()` \n4. Verifies that old records are removed from internal state\n\nThis ensures the cleanup mechanism works correctly to prevent memory leaks.",
    "created_at": "2025-11-28T17:46:06Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231418",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231418"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231418"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231418/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 84,
    "original_start_line": 80,
    "start_side": "RIGHT",
    "line": 95,
    "original_line": 91,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 91,
    "position": 95,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231419",
    "pull_request_review_id": 3519629052,
    "id": 2572231419,
    "node_id": "PRRC_kwDOKLjsIc6ZUSL7",
    "diff_hunk": "@@ -0,0 +1,132 @@\n+const {log} = Candy.core('Log', false).init('Firewall')\n+\n+class Firewall {\n+  #blacklist = new Set()\n+  #whitelist = new Set()\n+  #requestCounts = new Map() // IP -> { count, timestamp }",
    "path": "server/src/Web/Firewall.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "[nitpick] Performance concern: The `#requestCounts` Map can grow unbounded if many unique IPs make requests. While the `cleanup()` method runs every 60 seconds to remove old entries, under high traffic with many unique IPs, the Map could still grow large between cleanups. Consider:\n1. Adding a maximum size limit for the Map\n2. Using an LRU cache instead of a plain Map\n3. Running cleanup more frequently (e.g., every 10-30 seconds) if the Map exceeds a certain size",
    "created_at": "2025-11-28T17:46:07Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231419",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231419"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231419"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231419/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 9,
    "original_line": 6,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 6,
    "position": 9,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231421",
    "pull_request_review_id": 3519629052,
    "id": 2572231421,
    "node_id": "PRRC_kwDOKLjsIc6ZUSL9",
    "diff_hunk": "@@ -0,0 +1,132 @@\n+const {log} = Candy.core('Log', false).init('Firewall')\n+\n+class Firewall {\n+  #blacklist = new Set()\n+  #whitelist = new Set()\n+  #requestCounts = new Map() // IP -> { count, timestamp }\n+  #config = {}\n+  #cleanupInterval = null\n+\n+  constructor() {\n+    this.load()\n+    // Run cleanup every minute\n+    this.#cleanupInterval = setInterval(() => this.cleanup(), 60000)\n+    if (this.#cleanupInterval.unref) this.#cleanupInterval.unref()\n+  }\n+\n+  load() {\n+    // Load configuration from Candy.core('Config').config\n+    const config = Candy.core('Config').config.firewall || {}\n+\n+    this.#config = {\n+      enabled: config.enabled !== false,\n+      rateLimit: {\n+        enabled: config.rateLimit?.enabled !== false,\n+        windowMs: config.rateLimit?.windowMs || 60000, // 1 minute\n+        max: config.rateLimit?.max || 300 // limit each IP to 300 requests per windowMs\n+      },\n+      blacklist: new Set(config.blacklist || []),\n+      whitelist: new Set(config.whitelist || [])\n+    }\n+\n+    this.#blacklist = this.#config.blacklist\n+    this.#whitelist = this.#config.whitelist\n+  }\n+\n+  check(req) {\n+    if (!this.#config.enabled) return true\n+\n+    let ip = req.socket.remoteAddress || req.headers['x-forwarded-for']\n+    if (ip && ip.startsWith('::ffff:')) {\n+      ip = ip.substring(7)\n+    }\n+\n+    if (!ip) return true\n+\n+    // 1. Check whitelist (bypass everything)\n+    if (this.#whitelist.has(ip)) return true\n+\n+    // 2. Check blacklist\n+    if (this.#blacklist.has(ip)) {\n+      log(`Blocked request from blacklisted IP: ${ip}`)\n+      return false\n+    }\n+\n+    // 3. Rate limiting\n+    if (this.#config.rateLimit.enabled) {\n+      const now = Date.now()\n+      let record = this.#requestCounts.get(ip)\n+\n+      if (!record) {\n+        record = {count: 0, timestamp: now}\n+        this.#requestCounts.set(ip, record)\n+      }\n+\n+      // Check window\n+      if (now - record.timestamp > this.#config.rateLimit.windowMs) {\n+        // Reset window\n+        record.count = 1\n+        record.timestamp = now\n+      } else {\n+        record.count++\n+      }\n+\n+      if (record.count > this.#config.rateLimit.max) {\n+        if (record.count === this.#config.rateLimit.max + 1) {\n+          log(`Rate limit exceeded for IP: ${ip}`)\n+        }\n+        return false\n+      }\n+    }\n+\n+    return true\n+  }\n+\n+  // Cleanup method to run periodically\n+  cleanup() {\n+    const now = Date.now()\n+    const windowMs = this.#config.rateLimit.windowMs\n+\n+    for (const [ip, record] of this.#requestCounts) {\n+      if (now - record.timestamp > windowMs) {\n+        this.#requestCounts.delete(ip)\n+      }\n+    }\n+  }",
    "path": "server/src/Web/Firewall.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Potential bug: The `cleanup()` method accesses `this.#config.rateLimit.windowMs` without checking if `this.#config.rateLimit` exists. If the firewall is disabled or rate limiting is disabled, this could throw an error. Consider adding a guard:\n```javascript\ncleanup() {\n  if (!this.#config.rateLimit?.windowMs) return\n  const now = Date.now()\n  const windowMs = this.#config.rateLimit.windowMs\n  // ... rest of cleanup\n}\n```",
    "created_at": "2025-11-28T17:46:07Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231421",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231421"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231421"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231421/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 104,
    "original_start_line": 86,
    "start_side": "RIGHT",
    "line": 113,
    "original_line": 95,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 95,
    "position": 113,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231426",
    "pull_request_review_id": 3519629052,
    "id": 2572231426,
    "node_id": "PRRC_kwDOKLjsIc6ZUSMC",
    "diff_hunk": "@@ -0,0 +1,132 @@\n+const {log} = Candy.core('Log', false).init('Firewall')\n+\n+class Firewall {\n+  #blacklist = new Set()\n+  #whitelist = new Set()\n+  #requestCounts = new Map() // IP -> { count, timestamp }\n+  #config = {}\n+  #cleanupInterval = null\n+\n+  constructor() {\n+    this.load()\n+    // Run cleanup every minute\n+    this.#cleanupInterval = setInterval(() => this.cleanup(), 60000)\n+    if (this.#cleanupInterval.unref) this.#cleanupInterval.unref()\n+  }\n+\n+  load() {\n+    // Load configuration from Candy.core('Config').config\n+    const config = Candy.core('Config').config.firewall || {}\n+\n+    this.#config = {\n+      enabled: config.enabled !== false,\n+      rateLimit: {\n+        enabled: config.rateLimit?.enabled !== false,\n+        windowMs: config.rateLimit?.windowMs || 60000, // 1 minute\n+        max: config.rateLimit?.max || 300 // limit each IP to 300 requests per windowMs\n+      },\n+      blacklist: new Set(config.blacklist || []),\n+      whitelist: new Set(config.whitelist || [])\n+    }\n+\n+    this.#blacklist = this.#config.blacklist\n+    this.#whitelist = this.#config.whitelist",
    "path": "server/src/Web/Firewall.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "[nitpick] The configuration initialization code (lines 21-30) creates a nested object structure, but then directly assigns references to the Sets (lines 32-33). This means `this.#blacklist` and `this.#whitelist` are the same Set objects as `this.#config.blacklist` and `this.#config.whitelist`. While this works, it creates an unnecessary indirection and could be confusing. Consider either:\n1. Removing the redundant fields and using `this.#config.blacklist/whitelist` throughout\n2. Creating separate Sets if they serve different purposes",
    "created_at": "2025-11-28T17:46:07Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231426",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231426"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231426"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231426/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 27,
    "original_start_line": 21,
    "start_side": "RIGHT",
    "line": 39,
    "original_line": 33,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 33,
    "position": 39,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231430",
    "pull_request_review_id": 3519629052,
    "id": 2572231430,
    "node_id": "PRRC_kwDOKLjsIc6ZUSMG",
    "diff_hunk": "@@ -0,0 +1,106 @@\n+\n+// Mock dependencies\n+const mockLog = {\n+  log: jest.fn(),\n+  error: jest.fn(),\n+  init: jest.fn().mockReturnThis()\n+}\n+\n+// Mock Candy global\n+global.Candy = {\n+  core: jest.fn((module) => {\n+    if (module === 'Log') return mockLog\n+    if (module === 'Config') return {\n+      config: {\n+        firewall: {\n+            enabled: true,\n+            rateLimit: {\n+                enabled: true,\n+                windowMs: 1000,\n+                max: 2\n+            },\n+            blacklist: [],\n+            whitelist: []\n+        }\n+      }\n+    }\n+    return {}\n+  })\n+}\n+\n+const Firewall = require('../../../server/src/Web/Firewall.js')\n+\n+describe('Firewall', () => {\n+  let firewall\n+\n+  beforeEach(() => {\n+    jest.clearAllMocks()\n+    firewall = new Firewall()\n+  })\n+\n+  afterEach(() => {\n+     if (firewall.cleanupInterval) clearInterval(firewall.cleanupInterval)\n+  })\n+\n+  test('should allow requests from normal IPs', () => {\n+    const req = { socket: { remoteAddress: '127.0.0.1' }, headers: {} }\n+    expect(firewall.check(req)).toBe(true)\n+  })\n+\n+  test('should block requests from blacklisted IPs', () => {\n+    firewall.addBlock('1.2.3.4')\n+    const req = { socket: { remoteAddress: '1.2.3.4' }, headers: {} }\n+    expect(firewall.check(req)).toBe(false)\n+  })\n+\n+  test('should allow requests from whitelisted IPs even if rate limited', () => {\n+      // Mock rate limit config to be very strict\n+      firewall = new Firewall()\n+      // Manually set low limit\n+      firewall.addWhitelist('1.2.3.4')\n+\n+      const req = { socket: { remoteAddress: '1.2.3.4' }, headers: {} }\n+\n+      // Send many requests\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+  })\n+\n+  test('should enforce rate limits', () => {\n+      const req = { socket: { remoteAddress: '10.0.0.1' }, headers: {} }\n+\n+      // Config is max 2 per 1000ms\n+      expect(firewall.check(req)).toBe(true) // 1\n+      expect(firewall.check(req)).toBe(true) // 2\n+      expect(firewall.check(req)).toBe(false) // 3 - blocked\n+  })\n+\n+  test('should reset rate limits after window', async () => {\n+      const req = { socket: { remoteAddress: '10.0.0.2' }, headers: {} }\n+\n+      expect(firewall.check(req)).toBe(true) // 1\n+      expect(firewall.check(req)).toBe(true) // 2\n+      expect(firewall.check(req)).toBe(false) // 3\n+\n+      // Wait for window to pass (1000ms)\n+      await new Promise(resolve => setTimeout(resolve, 1100))\n+\n+      expect(firewall.check(req)).toBe(true) // Should be allowed again\n+  })\n+\n+  test('should handle IPv6 mapped IPv4 addresses', () => {\n+      const req = { socket: { remoteAddress: '::ffff:127.0.0.1' }, headers: {} }\n+      expect(firewall.check(req)).toBe(true)\n+\n+      firewall.addBlock('127.0.0.1')\n+      expect(firewall.check(req)).toBe(false)\n+  })\n+\n+  test('should use x-forwarded-for if socket address is missing', () => {\n+      const req = { socket: {}, headers: { 'x-forwarded-for': '1.2.3.4' } }\n+      firewall.addBlock('1.2.3.4')\n+      expect(firewall.check(req)).toBe(false)\n+  })\n+})",
    "path": "test/server/Web/Firewall.test.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Missing test coverage: There's no test verifying the `removeBlock()` and `removeWhitelist()` methods. These methods modify the blacklist/whitelist, and their functionality should be tested to ensure:\n1. Removing an IP from the blacklist allows requests from that IP\n2. Removing an IP from the whitelist subjects it to rate limiting again",
    "created_at": "2025-11-28T17:46:07Z",
    "updated_at": "2025-11-28T17:46:09Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231430",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231430"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231430"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231430/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 110,
    "original_line": 106,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 106,
    "position": 110,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231432",
    "pull_request_review_id": 3519629052,
    "id": 2572231432,
    "node_id": "PRRC_kwDOKLjsIc6ZUSMI",
    "diff_hunk": "@@ -0,0 +1,106 @@\n+\n+// Mock dependencies\n+const mockLog = {\n+  log: jest.fn(),\n+  error: jest.fn(),\n+  init: jest.fn().mockReturnThis()\n+}\n+\n+// Mock Candy global\n+global.Candy = {\n+  core: jest.fn((module) => {\n+    if (module === 'Log') return mockLog\n+    if (module === 'Config') return {\n+      config: {\n+        firewall: {\n+            enabled: true,\n+            rateLimit: {\n+                enabled: true,\n+                windowMs: 1000,\n+                max: 2\n+            },\n+            blacklist: [],\n+            whitelist: []\n+        }\n+      }\n+    }\n+    return {}\n+  })\n+}\n+\n+const Firewall = require('../../../server/src/Web/Firewall.js')\n+\n+describe('Firewall', () => {\n+  let firewall\n+\n+  beforeEach(() => {\n+    jest.clearAllMocks()\n+    firewall = new Firewall()\n+  })\n+\n+  afterEach(() => {\n+     if (firewall.cleanupInterval) clearInterval(firewall.cleanupInterval)\n+  })\n+\n+  test('should allow requests from normal IPs', () => {\n+    const req = { socket: { remoteAddress: '127.0.0.1' }, headers: {} }\n+    expect(firewall.check(req)).toBe(true)\n+  })\n+\n+  test('should block requests from blacklisted IPs', () => {\n+    firewall.addBlock('1.2.3.4')\n+    const req = { socket: { remoteAddress: '1.2.3.4' }, headers: {} }\n+    expect(firewall.check(req)).toBe(false)\n+  })\n+\n+  test('should allow requests from whitelisted IPs even if rate limited', () => {\n+      // Mock rate limit config to be very strict\n+      firewall = new Firewall()\n+      // Manually set low limit\n+      firewall.addWhitelist('1.2.3.4')\n+\n+      const req = { socket: { remoteAddress: '1.2.3.4' }, headers: {} }\n+\n+      // Send many requests\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+      expect(firewall.check(req)).toBe(true)\n+  })\n+\n+  test('should enforce rate limits', () => {\n+      const req = { socket: { remoteAddress: '10.0.0.1' }, headers: {} }\n+\n+      // Config is max 2 per 1000ms\n+      expect(firewall.check(req)).toBe(true) // 1\n+      expect(firewall.check(req)).toBe(true) // 2\n+      expect(firewall.check(req)).toBe(false) // 3 - blocked\n+  })\n+\n+  test('should reset rate limits after window', async () => {\n+      const req = { socket: { remoteAddress: '10.0.0.2' }, headers: {} }\n+\n+      expect(firewall.check(req)).toBe(true) // 1\n+      expect(firewall.check(req)).toBe(true) // 2\n+      expect(firewall.check(req)).toBe(false) // 3\n+\n+      // Wait for window to pass (1000ms)\n+      await new Promise(resolve => setTimeout(resolve, 1100))\n+\n+      expect(firewall.check(req)).toBe(true) // Should be allowed again\n+  })\n+\n+  test('should handle IPv6 mapped IPv4 addresses', () => {\n+      const req = { socket: { remoteAddress: '::ffff:127.0.0.1' }, headers: {} }\n+      expect(firewall.check(req)).toBe(true)\n+\n+      firewall.addBlock('127.0.0.1')\n+      expect(firewall.check(req)).toBe(false)\n+  })\n+\n+  test('should use x-forwarded-for if socket address is missing', () => {\n+      const req = { socket: {}, headers: { 'x-forwarded-for': '1.2.3.4' } }\n+      firewall.addBlock('1.2.3.4')\n+      expect(firewall.check(req)).toBe(false)\n+  })\n+})",
    "path": "test/server/Web/Firewall.test.js",
    "commit_id": "5c6ca0d16a0321fd24e325f83eb4eab660d89efc",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "Missing test coverage: The firewall can be disabled via the `enabled` configuration flag, but there's no test verifying that when `firewall.enabled = false`, all requests are allowed regardless of blacklist, whitelist, or rate limits. Consider adding a test that sets the configuration to disabled and verifies the firewall allows all requests.",
    "created_at": "2025-11-28T17:46:08Z",
    "updated_at": "2025-11-28T17:46:10Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231432",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231432"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231432"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231432/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 110,
    "original_line": 106,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 106,
    "position": 110,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231436",
    "pull_request_review_id": 3519629052,
    "id": 2572231436,
    "node_id": "PRRC_kwDOKLjsIc6ZUSMM",
    "diff_hunk": "@@ -186,6 +189,12 @@ class Web {\n   }\n \n   request(req, res, secure) {\n+    if (!this.#firewall.check(req)) {\n+      res.writeHead(429, {'Content-Type': 'text/plain'})\n+      res.end('Too Many Requests')\n+      return\n+    }",
    "path": "server/src/Web.js",
    "commit_id": "fac5be7607b208407a3eb251366e33668b49dcfd",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "[nitpick] Security concern: The firewall check happens after the request handler is invoked but before any routing logic. However, there's no mechanism to distinguish between blocked IPs trying to attack vs. legitimate users hitting rate limits. Consider logging blocked requests with IP addresses, timestamps, and block reasons (blacklist vs rate limit) for security monitoring and analysis.",
    "created_at": "2025-11-28T17:46:08Z",
    "updated_at": "2025-11-28T17:46:10Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231436",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231436"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231436"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231436/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 192,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 196,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 32,
    "position": 1,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231441",
    "pull_request_review_id": 3519629052,
    "id": 2572231441,
    "node_id": "PRRC_kwDOKLjsIc6ZUSMR",
    "diff_hunk": "@@ -0,0 +1,132 @@\n+const {log} = Candy.core('Log', false).init('Firewall')\n+\n+class Firewall {\n+  #blacklist = new Set()\n+  #whitelist = new Set()\n+  #requestCounts = new Map() // IP -> { count, timestamp }\n+  #config = {}\n+  #cleanupInterval = null\n+\n+  constructor() {\n+    this.load()\n+    // Run cleanup every minute\n+    this.#cleanupInterval = setInterval(() => this.cleanup(), 60000)\n+    if (this.#cleanupInterval.unref) this.#cleanupInterval.unref()\n+  }\n+\n+  load() {\n+    // Load configuration from Candy.core('Config').config\n+    const config = Candy.core('Config').config.firewall || {}\n+\n+    this.#config = {\n+      enabled: config.enabled !== false,\n+      rateLimit: {\n+        enabled: config.rateLimit?.enabled !== false,\n+        windowMs: config.rateLimit?.windowMs || 60000, // 1 minute\n+        max: config.rateLimit?.max || 300 // limit each IP to 300 requests per windowMs\n+      },\n+      blacklist: new Set(config.blacklist || []),\n+      whitelist: new Set(config.whitelist || [])\n+    }\n+\n+    this.#blacklist = this.#config.blacklist\n+    this.#whitelist = this.#config.whitelist\n+  }\n+\n+  check(req) {\n+    if (!this.#config.enabled) return true\n+\n+    let ip = req.socket.remoteAddress || req.headers['x-forwarded-for']\n+    if (ip && ip.startsWith('::ffff:')) {\n+      ip = ip.substring(7)\n+    }\n+\n+    if (!ip) return true\n+\n+    // 1. Check whitelist (bypass everything)\n+    if (this.#whitelist.has(ip)) return true\n+\n+    // 2. Check blacklist\n+    if (this.#blacklist.has(ip)) {\n+      log(`Blocked request from blacklisted IP: ${ip}`)\n+      return false\n+    }\n+\n+    // 3. Rate limiting\n+    if (this.#config.rateLimit.enabled) {\n+      const now = Date.now()\n+      let record = this.#requestCounts.get(ip)\n+\n+      if (!record) {\n+        record = {count: 0, timestamp: now}\n+        this.#requestCounts.set(ip, record)\n+      }\n+\n+      // Check window\n+      if (now - record.timestamp > this.#config.rateLimit.windowMs) {\n+        // Reset window\n+        record.count = 1\n+        record.timestamp = now\n+      } else {\n+        record.count++\n+      }\n+\n+      if (record.count > this.#config.rateLimit.max) {\n+        if (record.count === this.#config.rateLimit.max + 1) {\n+          log(`Rate limit exceeded for IP: ${ip}`)\n+        }\n+        return false\n+      }\n+    }\n+\n+    return true\n+  }\n+\n+  // Cleanup method to run periodically\n+  cleanup() {\n+    const now = Date.now()\n+    const windowMs = this.#config.rateLimit.windowMs\n+\n+    for (const [ip, record] of this.#requestCounts) {\n+      if (now - record.timestamp > windowMs) {\n+        this.#requestCounts.delete(ip)\n+      }\n+    }\n+  }\n+\n+  addBlock(ip) {\n+    if (this.#whitelist.has(ip)) this.#whitelist.delete(ip)\n+    this.#blacklist.add(ip)\n+    this.#save()\n+  }\n+\n+  removeBlock(ip) {\n+    this.#blacklist.delete(ip)\n+    this.#save()\n+  }\n+\n+  addWhitelist(ip) {\n+    if (this.#blacklist.has(ip)) this.#blacklist.delete(ip)\n+    this.#whitelist.add(ip)\n+    this.#save()\n+  }\n+\n+  removeWhitelist(ip) {\n+    this.#whitelist.delete(ip)\n+    this.#save()\n+  }\n+\n+  #save() {\n+    // Update the global config\n+    if (!Candy.core('Config').config.firewall) Candy.core('Config').config.firewall = {}\n+\n+    Candy.core('Config').config.firewall.blacklist = Array.from(this.#blacklist)\n+    Candy.core('Config').config.firewall.whitelist = Array.from(this.#whitelist)\n+    // Config module handles saving automatically when properties change if using Proxy,\n+    // but here we are modifying the object structure.\n+    // Assuming Config module watches for changes or we need to trigger save.\n+    // Looking at Config.js, it uses Proxy to detect changes.\n+  }\n+}\n+\n+module.exports = Firewall",
    "path": "server/src/Web/Firewall.js",
    "commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "original_commit_id": "31093bfdbc8dcd143d1a2e9d3d86cf190e5b1f22",
    "user": {
      "login": "Copilot",
      "id": 175728472,
      "node_id": "BOT_kgDOCnlnWA",
      "avatar_url": "https://avatars.githubusercontent.com/in/946600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Copilot",
      "html_url": "https://github.com/apps/copilot-pull-request-reviewer",
      "followers_url": "https://api.github.com/users/Copilot/followers",
      "following_url": "https://api.github.com/users/Copilot/following{/other_user}",
      "gists_url": "https://api.github.com/users/Copilot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Copilot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Copilot/subscriptions",
      "organizations_url": "https://api.github.com/users/Copilot/orgs",
      "repos_url": "https://api.github.com/users/Copilot/repos",
      "events_url": "https://api.github.com/users/Copilot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Copilot/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "[nitpick] Missing documentation: The `Firewall` class and its public methods (`check`, `addBlock`, `removeBlock`, `addWhitelist`, `removeWhitelist`) lack JSDoc comments explaining their purpose, parameters, and return values. This makes it harder for other developers to understand how to use the firewall API. Consider adding comprehensive documentation, especially for the `check()` method which returns a boolean indicating whether a request should be allowed.",
    "created_at": "2025-11-28T17:46:08Z",
    "updated_at": "2025-11-28T17:46:10Z",
    "html_url": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231441",
    "pull_request_url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231441"
      },
      "html": {
        "href": "https://github.com/CandyPack/CandyPack/pull/71#discussion_r2572231441"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/CandyPack/CandyPack/pulls/71"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/CandyPack/CandyPack/pulls/comments/2572231441/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 6,
    "original_start_line": 3,
    "start_side": "RIGHT",
    "line": 166,
    "original_line": 132,
    "side": "RIGHT",
    "author_association": "CONTRIBUTOR",
    "original_position": 132,
    "position": 1,
    "subject_type": "line"
  }
]
